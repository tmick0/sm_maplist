#include <sourcemod>

#pragma newdecls required
#pragma semicolon 1

public Plugin myinfo =
{
    name = "Map list generator",
    author = "tmick0",
    description = "Generates a map list",
    version = "0.1",
    url = "github.com/tmick0/maplist"
};

#define MAP_DIRECTORY "maps/"
#define MAP_SUFFIX ".bsp"
#define CVAR_FILTERFILEPATH "sm_maplist_filterfile"
#define CMD_WRITEMAPLIST "sm_writemaplist"
#define MAXDEPTH 5
#define ERROR_STRING_LEN 32
#define CHAT_BUFFER_LEN 128

#define ERR_WRITE_FILE -1
#define ERR_LOAD_FILTER -2
#define ERR_FIND_MAPS -3

ConVar CvarFilterFilePath;

public void OnPluginStart() {
    RegAdminCmd(CMD_WRITEMAPLIST, CmdWriteMapList, ADMFLAG_GENERIC);
    CvarFilterFilePath = CreateConVar(CVAR_FILTERFILEPATH, "", "path to list of maps to exclude; empty string disables the filter", FCVAR_REPLICATED | FCVAR_SPONLY);
    AutoExecConfig(true, "plugin_maplist");
}

public Action CmdWriteMapList(int client, int argc) {
    if (argc != 1) {
        ReplyToCommand(client, "Usage: sm_writemaplist <output>");
        return Plugin_Handled;
    }

    char output[PLATFORM_MAX_PATH];
    GetCmdArg(1, output, sizeof(output));

    int count = GenerateMapList(output);

    char buf[CHAT_BUFFER_LEN];
    if (count < 0) {
        char err[ERROR_STRING_LEN];
        ErrorString(count, err, ERROR_STRING_LEN);
        LogMessage("error generating maplist requested by %L: %s (%d)", client, err, count);
        Format(buf, CHAT_BUFFER_LEN, "[maplist] error generating maplist: %s (%d)", err, count);
    }
    else {
        LogMessage("new maplist generated by %L with %d entries", client, count);
        Format(buf, CHAT_BUFFER_LEN, "[maplist] new maplist generated with %d entries", count);
    }
    ReplyToCommand(client, buf);

    return Plugin_Handled;
}

int GenerateMapList(const char[] output) {
    char FilterFilePath[PLATFORM_MAX_PATH];
    GetConVarString(CvarFilterFilePath, FilterFilePath, PLATFORM_MAX_PATH);

    char tmp[1][1]; // nullable array refs pls
    int filterc = LoadFilter(FilterFilePath, 0, tmp);
    if (filterc < 0) {
        return filterc;
    }

    int filter_alloc = (filterc == 0) ? 1 : filterc;
    char[][] filterv = new char[filter_alloc][PLATFORM_MAX_PATH];
    if (LoadFilter(FilterFilePath, filterc, filterv) != filterc) {
        return ERR_LOAD_FILTER;
    }

    Handle fh = OpenFile(output, "w");
    if (fh == INVALID_HANDLE) {
        return ERR_WRITE_FILE;
    }

    int count = FindMaps(fh, MAP_DIRECTORY, 0, filterc, filterv);

    CloseHandle(fh);

    return count;
}

int LoadFilter(const char[] path, int filterc, char[][] filterv) {
    if (strlen(path) == 0) {
        return 0;
    }

    int count = 0;
    Handle fh = OpenFile(path, "r");
    if (fh == INVALID_HANDLE) {
        return ERR_LOAD_FILTER;
    }

    char line[PLATFORM_MAX_PATH];
    while (ReadFileLine(fh, line, PLATFORM_MAX_PATH)) {
        int len = strlen(line);
        if (line[len - 1] == '\n') {
            line[len - 1] = '\0';
            --len;
        }

        if (len > 0 && line[0] != '#') {
            if (count < filterc) {
                strcopy(filterv[count], PLATFORM_MAX_PATH, line);
            }
            ++count;
        }
    }

    CloseHandle(fh);
    return count;
}

int FindMaps(Handle output, char[] directory, int depth, int filterc, const char[][] filterv) {
    if (depth >= MAXDEPTH) {
        return 0;
    }

    // remove trailing slash
    int dlen = strlen(directory);
    if (directory[dlen - 1] == '/') {
        directory[dlen - 1] = '\0';
    }

    int count = 0;

    Handle dh = OpenDirectory(MAP_DIRECTORY);
    if (dh == INVALID_HANDLE) {
        return ERR_FIND_MAPS;
    }

    char entry[PLATFORM_MAX_PATH];
    FileType type;
    while (ReadDirEntry(dh, entry, PLATFORM_MAX_PATH, type)) {

        ReplaceString(entry, PLATFORM_MAX_PATH, "./", "");

        if (type == FileType_Directory) {
            // TODO: find a better way to exclude these dirs from recursion
            if (strcmp(entry, ".") && strcmp(entry, "..") && strcmp(entry, "graphs") && strcmp(entry, "soundcache") && strcmp(entry, "cfg")) {
                char cpath[PLATFORM_MAX_PATH];
                Format(cpath, PLATFORM_MAX_PATH, "%s/%s", directory, entry);

                // recurse
                int res = FindMaps(output, cpath, depth + 1, filterc, filterv);
                if (res < 0) {
                    CloseHandle(dh);
                    return res;
                }

                count += res;
            }
        }
        else if (type == FileType_File) {
            // check if it is a map
            int baselen = strlen(entry) - strlen(MAP_SUFFIX);
            if (StrContains(entry, MAP_SUFFIX) == baselen) {
                // check if it is in the filter
                // so its a linear search, sue me
                bool filtered = false;
                for (int i = 0; i < filterc; ++i) {
                    if (baselen == strlen(filterv[i]) && strncmp(entry, filterv[i], baselen, false) == 0) {
                        filtered = true;
                        break;
                    }
                }

                if (!filtered) {
                    WriteFileLine(output, "%s/%s", directory, entry);
                    ++count;
                }
            }
        }
    }

    CloseHandle(dh);
    return count;
}

void ErrorString(int code, char[] buffer, int buffersz) {
    if (code == ERR_WRITE_FILE) {
        strcopy(buffer, buffersz, "failed to write output file");
    }
    else if (code == ERR_LOAD_FILTER) {
        strcopy(buffer, buffersz, "failed to load filters");
    }
    else if (code == ERR_FIND_MAPS) {
        strcopy(buffer, buffersz, "failed to iterate map directory");
    }
    else {
        strcopy(buffer, buffersz, "unknown");
    }
}
